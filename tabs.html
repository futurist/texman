<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="css/normalize.css" />
<link rel="stylesheet" href="css/foundation.min.css" />
<link rel="stylesheet" href="css/font-awesome.min.css" />
<link rel="stylesheet" href="css/mytabs.css" />

<script src="js/vendor/modernizr.js"></script>
<script src="js/vendor/jquery.js"></script>
<!-- <script src="js/vendor/fastclick.js"></script> -->

<script src="js/foundation/foundation.js"></script>
<script src="js/foundation/foundation.tooltip.js"></script>

</head>
<body>

<div id="container"></div>
<script src="js/mithril.js"></script>
<script src="mValidator.js"></script>
<script src="dbdb.js"></script>
<script>

// 'use strict'

var host="http://1111hui.com:88"

var OBJECT = "[object Object]", ARRAY = "[object Array]", STRING = "[object String]", FUNCTION = "function";
var type = {}.toString;

/**
 * http://stackoverflow.com/questions/4459928/how-to-deep-clone-in-javascript
 */
function clone(item) {
    if (!item) { return item; } // null, undefined values check

    var types = [ Number, String, Boolean ],
        result;

    // normalizing primitives if someone did new String('aaa'), or new Number('444');
    types.forEach(function(type) {
        if (item instanceof type) {
            result = type( item );
        }
    });

    if (typeof result == "undefined") {
        if (Object.prototype.toString.call( item ) === "[object Array]") {
            result = [];
            item.forEach(function(child, index, array) {
                result[index] = clone( child );
            });
        } else if (typeof item == "object") {
            // testing that this is DOM
            if (item.nodeType && typeof item.cloneNode == "function") {
                var result = item.cloneNode( true );
            } else if (!item.prototype) { // check that this is a literal
                if (item instanceof Date) {
                    result = new Date(item);
                } else {
                    // it is an object literal
                    result = {};
                    for (var i in item) {
                        result[i] = clone( item[i] );
                    }
                }
            } else {
                // depending what you would like here,
                // just keep the reference, or create new object
                if (item.constructor) {
                    result = new item.constructor();
                } else {
                    result = item;
                }
            }
        } else {
            result = item;
        }
    }
    return result;
}

/**
 * COPY First Layer, and Reference sub child
 * @param  {obj:obj}, ...args
 * @return {obj}
 */
function extend(obj) {
    obj = obj || {};
    if(arguments.length<2) return obj;
    for(var i=1; i<arguments.length; i++){
        var props = arguments[i];
        for(var prop in props) {
            if( props.hasOwnProperty(prop) ) {
                obj[prop] = clone(props[prop]);
            }
        }
    }
    return obj;
}

// helpers
var futurist = {};

futurist.arrayUnique = function(array) {
  var a = [], i, j, l, o = {};
  for(i = 0, l = array.length; i < l; i++) {
    if(o[JSON.stringify(array[i])] === undefined) {
      a.push(array[i]);
      o[JSON.stringify(array[i])] = true;
    }
  }
  return a;
};
// remove val from array
futurist.removeFromTo = function(array, from, to) {
  var rest = array.slice((to || from) + 1 || array.length);
  array.length = from < 0 ? array.length + from : from;
  array.push.apply(array, rest);
  return array;
};
// remove val from array
futurist.removeFromSet = function(array, val) {
  var ret = array, tmp;
  while( (tmp = array.indexOf(val))>-1 )
    ret = futurist.removeFromTo(array, tmp);
  return ret;
};
// last array element
futurist.array_last_val = function(array) {
  return array.length ? array[array.length-1] : null;
};
futurist.addToSet = function(arr, val, isFirst) {
    if( !arr || arr.constructor !== Array ) arr=[];
    if(arr.indexOf(val)==-1){
        isFirst? arr.unshift(val) : arr.push(val)
    }
    return arr;
}


function NewID(){
    return +new Date() + "_" + (Math.round(Math.random() * 1e6)).toString(36)
    //return (+new Date()+Math.random()).toString(36);
}

/**
 * Underscore method list
 * @param  {[type]} func [description]
 * @param  {[type]} wait [description]
 * @return {[type]}      [description]
 */
var _delay = function(func, wait) {
    var args = [].slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
}
var _debounce = function(func, wait, immediate) {
  var timeout, result;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) result = func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) result = func.apply(context, args);
    return result;
  };
};

var Observable = function() {
    var channels = {}
    return {
        register: function(subscriptions, controller) {
            return function self() {
                var ctrl = new controller
                var reload = controller.bind(ctrl)
                Observable.on(subscriptions, reload)
                ctrl.onunload = function() {
                    Observable.off(reload)
                }
                return ctrl
            }
        },
        on: function(subscriptions, callback) {
            subscriptions.forEach(function(subscription) {
                if (!channels[subscription]) channels[subscription] = []
                channels[subscription].push(callback)
            })
        },
        off: function(callback) {
            for (var channel in channels) {
                var index = channels[channel].indexOf(callback)
                if (index > -1) channels[channel].splice(index, 1)
            }
        },
        trigger: function(channel, args) {
            console.log(channel)
            channels[channel].map(function(callback) {
                callback(args)
            })
        }
    }
}.call()

// Production steps of ECMA-262, Edition 5, 15.4.4.17
// Reference: http://es5.github.io/#x15.4.4.17
if (!Array.prototype.some) {
  Array.prototype.some = function(fun) {

    if (this == null) {
      throw new TypeError('Array.prototype.some called on null or undefined');
    }

    if (typeof fun !== 'function') {
      throw new TypeError();
    }

    var t = Object(this);
    var len = t.length >>> 0;

    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++) {
      if (i in t && fun.call(thisArg, t[i], i, t)) {
        return true;
      }
    }

    return false;
  };
}

Array.prototype.lastEl = function(fun) {
    return this.length? this[this.length-1] : null;
}


var mBindOnce = (function() {
    var cache = {}
    return function(view) {
        if (!cache[view.toString()]) {
            cache[view.toString()] = true
            return view()
        }
        else return {subtree: "retain"}
    }
}())

function skipReDraw(){
    m.redraw.strategy("none");
}
function beginReDraw(){
    m.redraw.strategy("diff");
}

function persistent(el, isInit, context) {
    context.retain = true;

    context.onunload = function() {
        //clearTimeout(context.timer);
    }

    if (!isInit) {
        //only runs once, even if you move back and forth between `/` and `/contact`
    }
}


/**
- Search for obj = [ {tag:1, attrs:{x:10}, children:[{tag:1, attrs:{z:20}, children:[...] } ]  } ]
- Usage: findKeyVal(obj, 'z', 20 )
- Return val: finded obj or null
**/
function findKeyVal(data, key, val) {
    var findingObj=null;

    function _find(data, key, val){
        if(typeof data!='object') return;
        if(findingObj) return true;
        if( data.some && data.length ) return data.some(function(v){
            return _find(v, key, val)
        })
        for(var i in data.attrs){
            if(i==key && val==data.attrs[i]){
                return findingObj=data;
            }
        }

        if(data.children&&data.children.length){
            for(i=0; i<data.children.length; i++){
                if( _find(data.children[i], key, val) ) return true;
            }
        }
    }
    _find.apply(this, arguments);

    return findingObj;
}

/**
 * [description]
 * @param  {Object} obj) {  var        self [description]
 * @return {[type]}      [description]
 */
var RecordTypes = (function(obj) {

    var self = {};

    self.dataModule = {};

    self.addModule = function( newObj ) {
        for(var i in newObj){
            newObj[i].template._type = i;
            newObj[i].fields = Object.keys(newObj[i].template);
            self.dataModule[i] = newObj[i];
        }
    }

    self.getModule = function( type ){
        return self.dataModule[type];
    }

    self.getTemplate = function( type ){
        var newObj={}
        var template = self.dataModule[type].template;
        for(var i in template){
            newObj[i] = clone(i=='_type'? template[i] : template[i].attrs.value)
        }
        return newObj;
    }

    self.addModule(obj);

    return self;

})(DBDB)



/**
 * [Record description]
 * @param {[type]} data [description]
 */
var Record = function(data) {
    data = data || {}
    this._key = NewID()
    this.getFields(data._type).forEach( function(v){
        this[v] = m.prop(data[v]||'')
    }.bind(this) )
}

Record.prototype.getFields = function(type) {
    return RecordTypes.getModule(type||this._type()).fields||[];
}

Record.prototype.toString = function() {
    return [].concat( this.getFields().map(function(v){ return this[v]() }.bind(this)) ).toString()
}

Record.prototype.clone = function(data) {
    var obj = { }

    this.getFields().forEach( function(v){
        obj[v] = this[v]()
    }.bind(this) )

    obj._key = NewID()

    return new Record(obj);
}

Record.prototype.copyFromRecord = function(obj, preserveKey) {
    obj = obj || {}

    this.getFields().forEach( function(v){
        this[v]( obj[v]()||'' )
    }.bind(this) )

    if(!preserveKey) this._key = NewID()
}


Record.getRecordList = function(data) {
    return m.request({
        method: "GET", url: host+'/views/dataJSON.json', data: data, initialValue:[], type:Record,
        unwrapSuccess: function(data) {
            return data.map(function(v){ v._type='Computer'; return v; });
        },
        unwrapError: function(response) {
            return response.error;
        }
    }).then(function(data){
        return data;
    })
}
Record.saveRecord = function(data) {
    return m.request({method: "POST", url: '/views/dataJSON.json', data: data, initialValue:[], type:Record}).then(function(data){
        console.log(data)
    })
}

/**
 * [RecordListWidget description]
 */
var RecordListWidget = function() {

    var self=this;

    self.curTabID = 0;
    self.generateID = NewID();

    self.module = {};
    self.module.init = function (data, keyword) {
        this.data = data;
        this.rowsperpage = 10;
        this.keyword = m.prop(keyword||'');
        this.newRec= new Record(RecordTypes.getTemplate('Computer'));
        this.newForm = new RecordForm(self, this.newRec );
        this.displayContainers = {}
        data.forEach(function(v){
             this.displayContainers[v._key] = new RecordDisplay( self, v )
        }.bind(this))
    }

    self.updateList= function update() {
        self.module.init( self.recordList() );
    }

    self.controller= function () {
        console.log( 'init RecordListWidget controller' )
        self.recordList = Record.getRecordList()
        self.RecordList = new RecordList( self );
    },
    self.view= function(ctrl) {
        return [
            self.RecordList
        ]
    }
}


/**
 * @param {parent} parent component
 * @param {curRecord} Object||String, if String then will find in RecordTypes for record template
 */
var RecordForm = function( parent, curRecord, mountCallBack ) {
    if(!curRecord) return;

    var self = this;

    // console.log(curRecord, curRecord._type(), curRecord[ _recordType.meta.mainKey ](), isNew )

    var _recordType = RecordTypes.getModule( curRecord._type() );
    var template = _recordType.template;
    var _mainKey = _recordType.meta.mainKey;
    var isNew = curRecord[ _mainKey ]() === '';
    var record = !isNew&& curRecord.clone() || curRecord;
    console.log('isNew', isNew, record._key, curRecord._key)
    var recordKeys = {}
    record.getFields().forEach(function  (v) {
        recordKeys[v] = NewID();
    })

    self.focusDiv = [];

    self.reset = function(e) {
        if(!window.confirm('已填的内容会丢失,确定重置?')){
            return
        }
        self.focusDiv = [];
        record = curRecord = new Record(RecordTypes.getTemplate( record._type() ));
        console.log(record['client']() )
        // record._key = NewID();
        console.log('reset', record._key)
        return;

    }
    self.cancel = function() {
        if(!window.confirm('内容将会还原，确定继续？') ) return;
        var form = new RecordDisplay(parent, curRecord, mountCallBack);
        parent.module.displayContainers[curRecord._key] = form;
        function mountCallBack () {
            var $dom = $('#panel'+curRecord._key+' .showForm');
            $dom.addClass('display');
        };

    }

    self.save = function() {
        // console.log(curRecord&&curRecord.toString(), record.toString())
        if(isNew){
            isNew = false;
            record[_mainKey](+new Date());
            parent.recordList().push( record )
            parent.updateList();
            parent.curTabID = parent.recordList().length-1;

        } else {
            parent.recordList().some(function(v,i){
                if(  v._key==curRecord._key ) {
                    parent.curTabID = i;
                    v.copyFromRecord(record, true);

                    var form = new RecordDisplay(parent, v, mountCallBack);
                    parent.module.displayContainers[v._key] = form;
                    function mountCallBack () {
                        var $dom = $('#panel'+v._key+' .showForm');
                        $dom.addClass('display');
                        m.redraw();
                    };

                    return true;
                }
            })
        }

        // _delay(m.redraw, 100);

        //Record.saveRecord(record).then(update.bind(this))
    }

    self.delaySet = _debounce( function(isError){ return isError?'has-tip':'labelTitle' }, 1000 );

    var checkErrors = mValidator(function(record, patterns, errorMsg, errors){
        var template = RecordTypes.getModule( record._type() ).template;

        record.getFields().forEach(function  (v) {
        	var t = template[v];
        	var value = record[v]();
            var pattern = t &&  t.attrs && t.attrs.pattern;
	        var isRequired = t.attrs&&t.attrs.required?'[required]':'';
	        if(isRequired && ( !value || typeof value=='object'&&!value.length ) ) {
	        	errors.add(v, '必填项' );
	        }
            if( pattern){
				if(typeof pattern=='string' && !patterns[ pattern ].test(value) ) {
	                errors.add(v, errorMsg[ pattern ] );
	            } else if(typeof pattern=='object'){
	            	pattern.forEach(function(pt){
	            		if(!patterns[ pt ].test(value)) errors.add(v, errorMsg[ pt ] );
	            	})
	            }
            }

        })
    })

    self.parseFormElement = function (v) {

        var t = clone(template[v]);
        t.attrs.type = t.attrs.type||'text';
        var errors = checkErrors(record);
        var isRequired = t.attrs&&t.attrs.required?'[required]':'';
        var isError = (self.focusDiv.indexOf(v)>-1)&&errors&&errors[v];
        var errorMsg = errors&&errors[v]&&errors[v].join('<br>')
        var isRadio = t.tag=='span' && t.attrs.type=='radio';
        var isCheckbox = t.tag=='span' && t.attrs.type=='checkbox';
        var isSelect = t.tag=='select';

        // if isMultiple, the value is Array type, and element is string type
        var isMultiple = isSelect&&t.attrs.multiple || isCheckbox;
        var SHOW_LABEL = true;

        // multiple select & checkbox,  all the options is String type, so we convert
        if( isMultiple && record[v]() && type.call( record[v]() )!==ARRAY ) record[v]( [String( record[v]() )] )

        // If default value to options, if not exists
        if((isSelect||isCheckbox||isRadio)&&t.attrs.value) futurist.addToSet( t.children, String(t.attrs.value), true );

    	// add current value to children if it's not exists
    	if(isSelect||isCheckbox||isRadio){
            var value = curRecord[v]();
            var options = [].concat.apply([], t.children);
            if( value&&value.constructor!==Array ){
                if( options.indexOf( value ) == -1 ) futurist.addToSet( options, String(value) );
            }
            if( value&&value.constructor==Array ){
                value.forEach(function(val){
                    if( val&&options.indexOf( val ) == -1 ) futurist.addToSet( options, String(val) );
                });
            }
            t.children = options
    	}

        function updateSet(isSet, key, val){
            record[key]( isSet ? futurist.addToSet(record[key](), val ) : futurist.removeFromSet(record[key](), val ) );
        }

        return m('div.inputWrap'+isRequired, {key:recordKeys[v], className:  isError?'valid-error':''  },  [

            SHOW_LABEL? m("label",
            	{ for: recordKeys[v], className:'title_'+ t.attrs.type },
            	[ m('span.labelTitle',
            		!errorMsg? {className:'' } :{'data-tooltip':'tooltip_'+recordKeys[v], className:'has-tip', title:errorMsg,
            		config:function(){ $('#tooltip_'+recordKeys[v]).html(errorMsg+'<span class="nub"></span>') } },
            		t.attrs.title) ]
            ) : [],

            m(  t.tag,

                (function() {
                    var attrs = extend( {}, t.attrs);
                    if( isSelect ) {
                    	var oninputFunc = function(){
                            futurist.addToSet(self.focusDiv, v );
                        	if( attrs.multiple ) {
                            	$(this).find('option').each( function(){
                            		updateSet( this.selected&&this.value, v, this.value );
                            	});
                        	} else {
                        		record[v]( this.value );
                        	}
                        }
                        extend( attrs,
                            {
                                id:recordKeys[v],
                                config: function(el){
                                	if( attrs.multiple && !record[v]() ) record[v]([]);
                                    $(el).val( record[v]() );
                                },
                                onchange: oninputFunc,
                                onblur: oninputFunc,
                                onpaste: oninputFunc,
                            }
                        )
                    } else if( isCheckbox ){
                        delete attrs.name;
                        extend( attrs,
                        {
                            id:recordKeys[v],
                        }
                        )

                    } else if( isRadio ){
                        delete attrs.name;
                        extend( attrs,
                        {
                            id:recordKeys[v],
                        }
                        )
                    } else {
                    	var oninputFunc=function(){
                        	record[v]( $(this).val() );
                        }
                        extend( attrs,
                            {
                                id:recordKeys[v],
                                onfocus: function(){
                                	futurist.addToSet(self.focusDiv, v);
                                },
                                onkeyup: oninputFunc,
                                onchange: oninputFunc,
                                onblur: oninputFunc,
                                onpaste: oninputFunc,
                                value: record[v]()
                            }
                        )

                    }
                    return attrs;

                })(),

                (function(){


                    if( isSelect ){
                        t.children = t.children.map(function(v){ return m('option', v) });
                        if( t.attrs.placeholder ) t.children.unshift( m('option', {disabled:true, value:''}, t.attrs.placeholder ) );
                        return t.children;

                    } else if( isCheckbox ) {
                        return t.children.map(function(opt){
                            var isChecked = record[v]().indexOf( opt )>-1;
                            return   m('label', [
                                        m('span.checkbox', opt),
                                        m('input', extend({}, t.attrs, {title:'', value:opt,
                                        	config:function(el){ if(isChecked) el.checked = 'checked'; },
                                        	onchange:function(){
                                            futurist.addToSet(self.focusDiv, v);
                                            updateSet( this.checked, v, this.value );
                                        } }) ) ] )
                        });

                    } else if( isRadio ) {
                        return t.children.map(function(opt){
                            var isChecked = record[v]().indexOf( opt )>-1;
                            var attr = extend({}, t.attrs, {title:'', value:opt,
                            				config:function(el){ if(isChecked) el.checked = 'checked'; },
                                        	onchange:function(){
                                            futurist.addToSet(self.focusDiv, v);
                                            record[v]( this.value )
                                        } });

                            return   m('label', [
                                        m('span.checkbox', opt),
                                        m('input', attr ) ] )
                        });

                    } else {

                    	return [];

                    }

                })()

            ),

        ])

    }


    this.controller= function(args) {
        console.log('New RecordForm render', isNew, record._key, curRecord._key);

        this.onunload = function() {
            console.log("unloading RecordForm component",record._key);
        }

        self.ctrl = this;
        if(typeof mountCallBack==FUNCTION) mountCallBack(self);

    },

    this.view= function(ctrl, args) {

        // console.log( record, record.toString(), record['client3']() )
        // to call from controller see github issue

        return m("form.mValidator[novalidate]", {key:record._key, config: null  }, [

            _recordType.fields.map(function  (v) {
                if(v=='_type') return [];
                // console.log('view: ', record._key, self.focusDiv, v)
                var d = self.parseFormElement( v );
                // console.log(JSON.stringify(d))
                return d
            }),

            m('div.buttons',{},
            [
            isNew ?m("button.secondary.button[type=button]", {onclick: self.reset }, "Reset")
                  :m("button.secondary.button[type=button]", {onclick: self.cancel }, "Cancel"),
                m("button[type=button]", {onclick: function(e){
                    if(! checkErrors(record) ){ self.save() }
                    else{
                        self.focusDiv = [].concat.apply([], _recordType.fields);
                        alert('请确保表单没有错误')
                    }
                } }, "Save")
            ])
        ]

        )
    }

    this.getView=function(){
    	return self.view( new self.controller() );
    }
}


var RecordDisplay = function( parent, curRecord, mountCallBack) {
    if(!curRecord) return;

    var self = this;

    var record = curRecord;

    var _recordType = RecordTypes.getModule( record._type() );
    var template = _recordType.template;

    self.remove = function() {
        console.log('remove', curRecord)
    }

    self.edit = function(e){

        var form = new RecordForm(parent, record, mountCallBack);
        parent.module.displayContainers[record._key] = form;
        function mountCallBack () {
            console.log('new edit form', record._key)
            var $dom = $('#panel'+record._key+' .showForm');
            $dom.removeClass('display');
        };

    }

    this.controller = function() {
        // console.log('new RecordDisplay', record._key, typeof(mountCallBack))
        this.onunload = function(e){
            // e.preventDefault();
            console.log('unload RecordDisplay', record._key)
        }
        self.ctrl = this;

        if( typeof mountCallBack===FUNCTION ) mountCallBack(self);
    }

    this.view= function(ctrl, args) {
        // console.log( record, record.toString() )
        return m("div", {config:null}, [

            _recordType.fields.map(function  (v) {
                if(v=='_type') return [];
                var t = template[v];

                // remove placeholder to hide from empty value
                var attrs = extend( {}, t.attrs );
                delete attrs.placeholder;

                return m('div', [
                    m("label", t.attrs.title),
                    m("input", extend(attrs, {disabled:true,readOnly:true, type:'text'}, { value: record[v]() } )  )
                ])
            }),

            m("button.alert.button[type=button]", {onclick: self.remove }, "Delete"),
            m("button.success.button[type=button]", {onclick: self.edit }, "Edit"),

        ]

        )
    }

    this.getView=function(){
    	return self.view( new self.controller() );
    }
}


var RecordList = function defRecordList ( parent ) {
    var self = this;

    self.controller = function (args) {
        parent.updateList();
        console.log('RecordList controller');
    };


    self.view =  function(ctrl, args) {
        var newRec = parent.module.newRec;
        // console.log('RecordList view', parent.module.data.length, parent.curTabID, parent.generateID);
        var active = parent.module.data.length==parent.curTabID?'active':'';

        return m('div', {key: parent.generateID }, [

            // m('.row', [
            //     m('input[placeholder="Filter by Name"][type="text"]', {
            //         onkeyup: m.withAttr('value', parent.module.keyword),
            //         value: parent.module.keyword()
            //     })
            // ]),

            m('.row', {key: parent.generateID, config:null}, [

                m('ul.tabs', {key: parent.generateID}, [

                            parent.module.data.map(function(obj,i){
                                var active = i==parent.curTabID?'active':'';
                                // console.log( 'iter',  obj.toString() )
                                return m('li.tab-title', { className:active, 'data-tabid':i, key:obj._key }, [
                                    m('a', {
                                        href:'javascript:;',
                                        onclick:function(){ parent.curTabID=i; }
                                    }, obj[ RecordTypes.getModule(obj._type()).meta.mainKey ]() ||'newuser')

                                ]);

                            }).concat( m('li.tab-title', { className:active, key:newRec._key, 'data-tabid': parent.module.data.length }, [m('a.addTab', { 
                            			href:'javascript:;', 
                            			onclick:function(){ parent.curTabID=parent.module.data.length; } 
                            		}, "+")] ) )


                ]),

                m('div.tabs-content', {key: parent.generateID }, [
                    parent.module.data.map(function(obj,i){
                        var active = i==parent.curTabID?'active':'';
                        // console.log( 'iter',  obj.toString() )
                        return m('div.content.panel#panel'+obj._key,
                            {className:active, key:obj._key, role:'tabpanel'},
                            [m('div.showForm.display', {className:''}, parent.module.displayContainers[obj._key]  )]
                        )
                    })
                    .concat( function() {
                        // console.log(1234, active, newRec._key)
                        // alert( JSON.stringify( parent.module.newForm.getView() ) )
                        return m('div.content.panel#addTab', { key:newRec._key, className:active}, [m('div.addForm', {key: newRec._key, className:''}, parent.module.newForm.getView() )] )
                    }() )

                ])

            ])


        ])
    }

}

var RecordList1 = new RecordListWidget;
m.mount(document.querySelector('#container'), RecordList1)

function initFundation(el, exists, context, vdom){

    // console.log(a,b,c, d)
    $(document).foundation();

}

</script>


</body>
</html>